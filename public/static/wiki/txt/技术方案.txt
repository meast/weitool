<h3> <span class="mw-headline" id=".E9.98.85.E8.AF.BB.E9.A1.BB.E7.9F.A5"><b>阅读须知</b></span></h3><p>1. EncodingAESKey长度固定为43个字符，从a-z,A-Z,0-9共62个字符中选取，公众帐号可以在公众平台的开发者中心的服务器配置修改；</p><p>2. AES密钥：AESKey=Base64_Decode(EncodingAESKey + “=”)，EncodingAESKey尾部填充一个字符的“=”, 用Base64_Decode生成32个字节的AESKey；</p><p>3. AES采用CBC模式，秘钥长度为32个字节，数据采用PKCS#7填充；PKCS#7：K为秘钥字节数（采用32），buf为待加密的内容，N为其字节数。Buf需要被填充为K的整数倍。在buf的尾部填充(K-N%K)个字节，每个字节的内容是(K- N%K)；</p><table border="1" cellspacing="0" cellpadding="4" align="center" width="400px"><tr><th style="width:120px">尾部填充</th><th></th></tr><tr><td> 01</td><td> if ( N%K==(K-1))</td></tr><tr><td> 0202</td><td> if ( N%K==(K-2))</td></tr><tr><td> 030303</td><td> if ( N%K==(K-3))</td></tr><tr><td> -40003</td><td> 计算签名失败</td></tr><tr><td> ...</td><td> ...</td></tr><tr><td> KK....KK (K个字节)</td><td> if ( N%K==0)</td></tr></table><p>具体详见：<a href="http://tools.ietf.org/html/rfc2315" class="external free" rel="nofollow">http://tools.ietf.org/html/rfc2315</a></p><p>5. 出于安全考虑，公众平台网站提供了修改EncodingAESKey的功能（在EncodingAESKey可能泄漏时进行修改），所以建议公众账号保存当前的和上一次的EncodingAESKey，若当前EncodingAESKey生成的AESKey解密失败，则尝试用上一次的AESKey的解密。<b>回包时，用哪个AESKey解密成功，则用此AESKey加密对应的回包</b>；</p><p>6. 兼容模式消息体同时存在明文和密文，消息体会增至以前的3倍左右，开发者注意检查系统，<b>防止因消息变长和URL参数增加而出现接收错误</b>；</p><p>7. 微信团队提供了多种语言的示例代码（包括PHP、Java、Ruby、Python、C#），请开发者尽量使用示例代码。</p><p><br />下面以普通文本消息为例，详细说明公众平台对消息体加解密的方法和流程，其它普通消息和事件消息的加解密可以此类推。</p><h3> <span class="mw-headline" id=".E5.85.AC.E4.BC.97.E8.B4.A6.E5.8F.B7.E6.8E.A5.E6.94.B6.E7.94.A8.E6.88.B7.E6.B6.88.E6.81.AF"><b>公众账号接收用户消息</b></span></h3><p><b>消息体加密</b></p><p>现有消息为明文，格式如下：</p><pre>msg = &lt;xml&gt;	&lt;ToUserName&gt;&lt;![CDATA[toUser]]&gt;&lt;/ToUserName&gt;	&lt;FromUserName&gt;&lt;![CDATA[fromUser]]&gt;&lt;/FromUserName&gt; 	&lt;CreateTime&gt;1348831860&lt;/CreateTime&gt;	&lt;MsgType&gt;&lt;![CDATA[text]]&gt;&lt;/MsgType&gt;	&lt;Content&gt;&lt;![CDATA[this is a test]]&gt;&lt;/Content&gt;	&lt;MsgId&gt;1234567890123456&lt;/MsgId&gt;&lt;/xml&gt;</pre><p><br />兼容模式期间同时保留明文和密文，消息格式如下：</p><pre>new_msg=&lt;xml&gt;	&lt;ToUserName&gt;&lt;![CDATA[toUser]]&gt;&lt;/ToUserName&gt;	&lt;FromUserName&gt;&lt;![CDATA[fromUser]]&gt;&lt;/FromUserName&gt; 	&lt;CreateTime&gt;1348831860&lt;/CreateTime&gt;	&lt;MsgType&gt;&lt;![CDATA[text]]&gt;&lt;/MsgType&gt;	&lt;Content&gt;&lt;![CDATA[this is a test]]&gt;&lt;/Content&gt;	&lt;MsgId&gt;1234567890123456&lt;/MsgId&gt;	&lt;Encrypt&gt;&lt;![CDATA[msg_encrypt]]&lt;/Encrypt&gt;&lt;/xml&gt;</pre><p>安全模式下，消息体只有密文，格式如下：</p><pre>new_msg=&lt;xml&gt; 	&lt;ToUserName&gt;&lt;![CDATA[toUser]]&lt;/ToUserName&gt;   &lt;Encrypt&gt;&lt;![CDATA[msg_encrypt]]&lt;/Encrypt&gt;&lt;/xml&gt;</pre><p>其中，msg_encrypt = Base64_Encode( AES_Encrypt[ random(16B) + msg_len(4B) + msg + $AppId] )</p><p>AES加密的buf由16个字节的随机字符串、4个字节的msg_len(网络字节序)、msg和$AppId组成，其中msg_len为msg的长度，$AppId为公众帐号的AppId</p><p>AESKey =Base64_Decode(EncodingAESKey  + “=”),32个字节</p><p>url上增加参数encrypt_type，encrypt_type的值为raw时表示为不加密，encrypt_type的值为aes时，表示aes加密（暂时只有raw和aes两种值)，无encrypt_type参数同样表示不加密</p><p><br /><b>消息体签名</b></p><p>为了验证消息体的合法性，公众平台新增消息体签名，开发者可用以验证消息体的真实性，并对验证通过的消息体进行解密</p><p>在url上增加参数：msg_signature</p><p>msg_signature=sha1(sort(Token、timestamp、nonce, msg_encrypt))</p><table border="1" cellspacing="0" cellpadding="4" align="center" width="400px"><tr><th style="width:120px">参数</th><th>说明</th></tr><tr><td> Token</td><td> 公众平台上，开发者设置的Token</td></tr><tr><td> timestamp</td><td> URL上原有参数，时间戳</td></tr><tr><td> nonce</td><td> URL上原有参数，随机数</td></tr><tr><td> msg_encrypt</td><td> 前文描述密文消息体</td></tr></table><p><br /><b>消息体验证和解密</b></p><p>开发者先验证消息体签名的正确性，验证通过后，再对消息体进行解密。</p><p><br /><b>验证方式</b></p><p>1. 开发者计算签名，dev_msg_signature=sha1(sort(Token、timestamp、nonce, msg_encrypt))</p><p>2. 比较dev_msg_signature和URL上带的msg_signature是否相等，相等则表示验证通过</p><p><br /><b>解密方式如下：</b></p><p>1. aes_msg=Base64_Decode(msg_encrypt)</p><p>2. rand_msg=AES_Decrypt(aes_msg)</p><p>3. 验证尾部$AppId是否是自己的AppId，相同则表示消息没有被篡改，这里进一步加强了消息签名验证</p><p>4. 去掉rand_msg头部的16个随机字节，4个字节的msg_len,和尾部的$AppId即为最终的xml消息体</p><p><br /></p><h3> <span class="mw-headline" id=".E5.85.AC.E4.BC.97.E8.B4.A6.E5.8F.B7.E5.90.91.E7.94.A8.E6.88.B7.E5.9B.9E.E5.A4.8D.E6.B6.88.E6.81.AF"><b>公众账号向用户回复消息</b></span></h3><p>如果url上无encrypt_type或者其值为raw，则回复明文，否则按照上述的加密算法加密回复密文。兼容模式期间公众账号回复<b>明文或密文均可（不要两种类型都回）</b></p><p><b>回复消息体的签名与加密</b></p><p>现有消息格式：</p><pre>msg=&lt;xml&gt;	 &lt;ToUserName&gt;&lt;![CDATA[toUser]]&gt;&lt;/ToUserName&gt;	 &lt;FromUserName&gt;&lt;![CDATA[fromUser]]&gt;&lt;/FromUserName&gt;	 &lt;CreateTime&gt;12345678&lt;/CreateTime&gt;	 &lt;MsgType&gt;&lt;![CDATA[text]]&gt;&lt;/MsgType&gt;	 &lt;Content&gt;&lt;![CDATA[你好]]&gt;&lt;/Content&gt;&lt;/xml&gt;</pre><p><br /> 加密后消息格式：</p><pre>new_msg=&lt;xml&gt;	&lt;Encrypt&gt;&lt;![CDATA[msg_encrypt]]&gt;&lt;/Encrypt&gt;	&lt;MsgSignature&gt;&lt;![CDATA[msg_signature]]&gt;&lt;/MsgSignature&gt;	&lt;TimeStamp&gt;timestamp&lt;/TimeStamp&gt;	&lt;Nonce&gt;&lt;![CDATA[nonce]]&gt;&lt;/Nonce&gt;&lt;/xml&gt; </pre><p>其中，msg_encrypt=Base64_Encode(AES_Encrypt [random(16B)+ msg_len(4B) + msg + $AppId]) </p><p>random(16B)为16字节的随机字符串；msg_len为msg长度，占4个字节(网络字节序)，$AppId为公众账号的AppId</p><p>AESKey =Base64_Decode(EncodingAESKey  + “=”),32个字节</p><p>msg_signature=sha1(sort(Token、timestamp、nonce, msg_encrypt))</p><p>timestamp、nonce回填请求中的值或者重新生成均可</p><!-- NewPP limit reportPreprocessor node count: 10/1000000Post-expand include size: 0/2097152 bytesTemplate argument size: 0/2097152 bytesExpensive parser function count: 0/100--><div class="printfooter">取自“<a href="http://mp.weixin.qq.com/wiki/index.php?title=%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88">http://mp.weixin.qq.com/wiki/index.php?title=%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88</a>”</div>